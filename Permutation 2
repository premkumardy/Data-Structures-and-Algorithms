class Solution:
    def permuteUnique(self, nums):
        nums.sort()  # Step 1: sort to keep duplicates together
        result = []
        used = [False] * len(nums)  # Track if element is already in current permutation

        def backtrack(current):
            # If permutation is complete, add a copy to result
            if len(current) == len(nums):
                result.append(current[:])
                return

            for i in range(len(nums)):

                # If this element is already used, skip it
                if used[i]:
                    continue

                # Skip duplicates:
                # If current num == previous num AND the previous one is NOT used,
                # then using this now would create a duplicate permutation.
                if i > 0 and nums[i] == nums[i - 1] and not used[i - 1]:
                    continue

                # Choose this element
                used[i] = True
                current.append(nums[i])

                # Explore further
                backtrack(current)

                # Undo the choice (backtrack)
                current.pop()
                used[i] = False

        backtrack([])
        return result



class Solution:
    def permuteUnique(self, nums):
        """
        Iterative solution using next_permutation.
        Returns a list of unique permutations of nums.
        """
        # 1. Start from the sorted (lowest lexicographic) permutation
        nums.sort()
        result = []
        
        # Helper: generate the current permutation copy into result
        def save_current():
            # append a shallow copy so later modifications don't change saved lists
            result.append(nums[:])
        
        # Helper: implement next_permutation in-place on nums
        def next_permutation():
            # Step 1: find the first index 'i' from the right where nums[i] < nums[i+1]
            i = len(nums) - 2
            while i >= 0 and nums[i] >= nums[i + 1]:
                i -= 1
            
            # If no such i, this is the last permutation
            if i == -1:
                return False  # no next permutation
            
            # Step 2: find the smallest j > i from the right where nums[j] > nums[i]
            j = len(nums) - 1
            while nums[j] <= nums[i]:
                j -= 1
            
            # Step 3: swap nums[i] and nums[j]
            nums[i], nums[j] = nums[j], nums[i]
            
            # Step 4: reverse the suffix nums[i+1:] to get the next smallest order
            left, right = i + 1, len(nums) - 1
            while left < right:
                nums[left], nums[right] = nums[right], nums[left]
                left += 1
                right -= 1
            
            return True  # next permutation generated

        # Save the first (sorted) permutation
        save_current()
        
        # Repeatedly generate next permutation until exhausted
        while next_permutation():
            save_current()
        
        return result

